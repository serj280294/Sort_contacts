#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <windows.h>

#define NAMESLEN  30 // Длина строк, хранящих имя, фамилию, отчество
#define NUMLEN    20 // Длина строки, хранящей телефонный номер

#define READ_ONLY "r"
#define ERROR_OPEN_INPUT_FILE -1 // Код ошибки чтения входного файла

#define CSFILE  "data/input.txt"  // Файл со списком контактов
#define SCSFILE "data/output.txt" // Файл с отсортированным списком контактов

typedef struct scts {
    char fname[NAMESLEN]; // Хранит имя
    char lname[NAMESLEN]; // Хранит фамилию
    char ptnmc[NAMESLEN]; // Хранит отчество
    char tnumb[NUMLEN];   // Хранит телефонный номер
} contstr;

contstr** getContacts(int *res);
int cpstrobj(const void *a, const void *b);
void printlst(const contstr** cslst, int lstlen);

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    contstr **cts = NULL; // Указатель на массив строк, прочитанных из файла
    int resgs = 0;        // Переменная, хранящая число прочитанных строк или код ошибки
    int i = 0;

    if (!(cts = getContacts(&resgs)))
        return resgs;

    printf("Исходный список:\n");
    printlst(cts, resgs); // Выводит на консоль содержимое массива

    qsort(cts, resgs, sizeof(cts), cpstrobj);

    printf("\nОтсортированный список:\n");
    printlst(cts, resgs); // Выводит на консоль содержимое массива

    return 0;
}

// printlst: выводит на экран содержимое массива
void printlst(const contstr** cslst, int lstlen)
{
    int i = 0;

    while (i < lstlen) {
        printf("%s %s %s %s\n", cslst[i]->fname, cslst[i]->lname, cslst[i]->ptnmc, cslst[i]->tnumb);
        ++i;
    }
}

// cpstrobj: сравнивает два объекта из множества
int cpstrobj(const void *a, const void *b)
{
    int res = 0;

    if (res = strcmp((*((contstr**)a))->fname, (*((contstr**)b))->fname)) {
        return res;
    }
    // Если имена совпадают - сравнить фамилии
    else if (res = strcmp((*((contstr**)a))->lname, (*((contstr**)b))->lname)) {
        return res;
    }
    // Если фамилии совпадают - сравнить отчества
    else if (res = strcmp((*((contstr**)a))->ptnmc, (*((contstr**)b))->ptnmc)) {
        return res;
    }
    else
        return 0; // Строки одинаковы
}

// getContacts: возвращает указатель на множество объектов структуры или NULL, в случае ошибки
// по адресу st помещает количество объектов множества, или номер ошибки
contstr** getContacts(int *res)
{
    FILE *csFile;            // Указатель на поток открытого файла
    contstr **csList = NULL; // Список указателей на объекты структуры, хранящие записи файла
    contstr entry;           // Хранит строку записи телефонной книги, считанной из файла
    int stcnt = 0;           // Счетчик строк, прочитанных из файла

    int i = 0;

    if ((csFile = fopen(CSFILE, READ_ONLY)) == NULL) {
        *res = ERROR_OPEN_INPUT_FILE;
        return NULL;
    }

    // Выделяем память для хранения указателей на объекты структуры
    csList = (contstr **) malloc(15 * sizeof(contstr *));

    while(fscanf(csFile, "%s %s %s %s", &entry.fname, &entry.lname, &entry.ptnmc, &entry.tnumb) != EOF) {
        // Выделяем память для объекта структуры
        csList[stcnt] = (contstr*) malloc(sizeof(contstr));

        // Перенос строковых данных
        memccpy(csList[stcnt]->fname, entry.fname, (int)'\0', sizeof(csList[stcnt]->fname));
        memccpy(csList[stcnt]->lname, entry.lname, (int)'\0', sizeof(csList[stcnt]->lname));
        memccpy(csList[stcnt]->ptnmc, entry.ptnmc, (int)'\0', sizeof(csList[stcnt]->ptnmc));
        memccpy(csList[stcnt]->tnumb, entry.tnumb, (int)'\0', sizeof(csList[stcnt]->tnumb));

        ++stcnt;
    }

    // Перераспределить память

    *res = stcnt;
    return csList;
}
